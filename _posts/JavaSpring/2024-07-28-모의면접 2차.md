---
layout: single
title:  "[JavaSpring] 기술 면접 2차"
date:   2024-07-30 09:00:00 +0900
categories: JavaSpring
author_profile: true
sidebar:
  nav: "main"
tags : 
    - JavaSpring
---

## 상속, 오버라이딩에 대한 개념을 이해하고 설명이 가능하다.

##### 상속
- super 클래스의 속성과 메서드를 자식 클래스가 물려받는 것을 의미합니다.
- 코드의 재사용성을 높이고, 보다 적은 양으로 클래스를 작성할 수 있습니다.
- 코드를 공통적으로 관리할 수 있기에 코드의 추가 및 변경이 용이합니다.
- 자식 클래스에는 생성자와 초기화 블록을 상속되지 않고 멤버만 상속됩니다.
- object클래스는 모든 클래스의 조상 클래스입니다.
- super()를 통해 조상클래스의 생성자를 호출합니다.

##### 오버라이딩
- 자식클래스가 부모 클래스에서 상속받은 메서드를 재정의하는 것을 의미합니다.
- 부모클래스 메서드와 동일한 메서드 이름, 매개변수 리스트를 가져야하며 더 넓은 범위의 접근 제어자를 가져야합니다.
- 반환 타입은 부모클래스의 메서드와 동일하거나 부모 클래스 메서드 반환타입의 서브타입이어야합니다.
- 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없으며, static메소드를 취소하거나 변경할 수 없습니다.

##### 오버로딩
- 같은 이름의 메서드를 여러 개 정의하는 것을 의미합니다.
- 각 메서드의 개수 또는 타입이 달라야합니다.
- 이를 통해 다양한 작업을 같은 이름의 메서드로 처리할 수 있습니다.

## 추상클래스와 인터페이스의 차이


## 프로세스와 쓰레드에 대한 개념을 이해하고 설명이 가능하다.

#### 프로세스
- 메모리에서 실행되는 실행주체로 메모리에 로드되어 실행되고 있는 프로그램의 인스턴스입니다.
- 실행과 스케줄링의 기본단위 이며 PID를 이용하여 이름이 지정됩니다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스에 직접적으로 접근할 수 없습니다.
  - 다른 프로세스에 접근하기 위해서는 IPC를 사용하여야합니다.
- 프로세스는 address space, OS resource, Hardware execution state 등 많은 정보를 담고 있거 모든 자료구조를 할당하고 초기화함으로써 메모리와 시스템 리소스를 많이 사용하며 IPC는 OS를 거쳐야 하기에 굉장히 무겁습니다.
- 멀티 프로세싱에서 하나의 자식 프로세스에서 문제가 발생하더라도 다른 프로세스에는 영향을 주지 않습니다.
- 컨텍스트 스위칭 중 캐시 메모리 초기화 등 무거운 작업이 진행되는 등 오버헤드가 발생하며 프로세스 간 공유 메모리가 없기에 컨텍스트 스위칭 시 데이터를 모두 리셋하고 다시 정보를 불러옵니다.

##### Process Address Space
- code : CPU Instruction이 있으며 순차적으로 실행됩니다.
- Data segment : 프로그림이 실행되는동안 항상 메모리를 차지하는 static data, 전역변수 등을 저장합니다.
- heap : 동적 할당에 사용합니다.
- stack : 지역 변수를 저장하며 stack pointer를 탑재합니다.

##### Process State
- new / ready / running / waiting / terminated 상태가 있습니다.
- ready : process가 실행가능한 상태이며 스케줄러가 ready 상태의 프로세스 중 실행한 프로세스를 선택합니다.
- dispatch : 스케줄링 된 ready 상태의 프로세스를 CPU의 레지스터에 올립니다.
- Waiting : I/O나 이벤트의 발생까지 대기하거나 DISK I/O가 이루어질 때까지 기다리는 상태이며, I/O가 완료되면 실행 중이던 프로세스는 Ready가 되며 대기하던 프로세스는 ready -> running 상태로 변경됩니다.

##### IPC
- MESSAGE PASSING : FIFO, Message queue 등을 이용하여 한 프로세스가 다른 프로세스에 미시지를 전송하여 데이터를 교환하는 방식입니다.
  - 직접적인 메모리 공유를 하지 않기에 데이터 충돌 문제를 방지할 수 있습니다.
- shared memory : 여러 프로세스가 동일한 메모리 공간을 공유하여 데이터를 교환하는 방식입니다.
  - 빠른 데이터 교환이 가능하지만 데이터 일관성 유지를 위해 동기화 메커니즘이 필요합니다.

#### Thread
- 프로세스 내에서 실행되는 가장 작은 단위입니다.
- 프로세스는 기본적으로 1개의 메인 쓰레드를 가지며 복수 개의 쓰레드를 가질 수 있습니다.
- 같은 프로세스 내의 다른 쓰레드와 메모리 공간과 자원을 공유하며 Stack부분만을 따로 할당받습니다.
- 메모리와 자원을 공유하므로 데이터의 교환도 쉽고 빠르며, 컨텍스트 스위칭에서도 더 빠릅니다.
- 또한 멀티 쓰레딩을 통해 병렬처리를 효율적으로 수행할 수 있습니다.

#### context switching
- OS에서 현재 실행 중인 프로세스나 쓰레드를 다른 프로세스나 쓰레드로 제어를 전환하는 과정입니다.
- Interrupt나 system call 등을 통해 제어의 전환이 필요할 때 프로세스나 쓰레드의 CPU 레지스터 상태(PC, STACK POINTER ETC)와 프로세스 상태 관련 정보를 PCB 혹은 TCB에 저장합니다.
- 다음에 실행할 프로세스나 쓰레드의 레지스터 상태와 상태를 PCB 혹은 TCB에서 복원합니다.

##### 멀티태스킹
- 컨텍스트 스위치는 운영체제가 여러 프로세스나 쓰레드를 관리하여 사용자가 여러 애플리케이션을 동시에 사용할 수 있게 해줍니다.

##### 반응성
- 오버헤드가 발생하지만 시스템은 높은 응답성을 유지하며, 사용자의 요청이나 중요한 작업에 신속하게 대응할 수 있습니다.

##### 자원할당
- 시스템 자원을 효율적으로 할당하고, CPU 시간을 다양한 프로세스와 쓰레드에 공평하게 분배합니다.

##### Non-Preemptive Scheduling
- 이미 할당된 CPU 를 다른 프로세스가 빼앗을 수 없는 기법
- Process 가 waiting state 가 되거나 끝났을 때만 context switching 이 발생

##### Preemptive Scheduling
- scheduler 가 job 을 interrupt 하여 context switching 이 가능한 scheduling
- 실행 중인 프로세스를 중단시키고 우선 순위가 높은 프로세스에게 CPU 할당이 가능한 기법

## Optional
- if문을 통한 유효성 검사는 예외를 완벽히 처리할 수 없고 코드의 가독성이 떨어집니다.
- Optional은 NullPointException 발생을 피하기 위해 사용하며, null 값을 가질 수 있음을 명시적으로 표현할 수 있습니다.

##### Optional.of()
- null이 아닌 값을 가진 상태에서 Optional 객체를 생성할 때 사용합니다.
- null 값이 입력된다면 NullPointException 발생함으로 객체에 입력될 값으로 null은 고려하지 않습니다.

##### Optional.ofNullable()
- 값이 null일 수도 있는 상황에서 Optional 객체를 생성할 때 사용합니다.
- 주어진 값이 null인 경우 빈 Optional을 반환합니다.

##### Optional.empty()
- 내부 값이 비어있는 Optional을 반환합니다.
- 주로 반환값이 null인 경우 사용합니다.

##### isPresent()
- Optional 내부에 값이 있는지 여부에 대해 논리값으로 반환하는 메소드입니다.

##### isEmpty()
- Optional 객체의 값이 null인지에 대한 논리값을 반환합니다.

##### ifPresent()
- 값이 존재하는 경우 주어진 동작을 수행합니다.

##### get() / orElse()
- get()은 값이 존재하는 경우 값을 반환하며 값을 가진다고 확신할 때 사용합니다.
- orElse()는 값이 존재하면 값을 반환하고, 그렇지 않으면 주어진 기본값을 반환합니다.

##### orElseThrow()
- 값이 존재하면 그 값을 반환하고, 그렇지 않으면 주어진 예외를 발생시킵니다.

##### map()
- 값이 존재하면 주어진 함수를 적용하고, 결과를 포함한 새로운 Optional을 반환합니다.
- 변환함수가 일반 값을 반환합니다.

##### flatmap()
- 값이 존재하면 주어진 함수를 적용하고, 그 함수가 반환하는 Optional의 값을 포함한 새로운 Optional을 반환합니다.
- 적용되는 함수가 optional을 반환하는 경우에 사용되며, 중복된 optional 사용을 피할 수 있습니다.