---
layout: single
title:  "[JavaSpring] 모의 면접 2차"
date:   2024-06-27 09:00:00 +0900
categories: JavaSpring
author_profile: true
sidebar:
  nav: "main"
tags : 
    - JavaSpring
---

## JPA에서 Lazy Loading과 Eager Loading의 차이점은 무엇인가요? 각각의 장단점에 대해 설명해 주세요.

##### Lazy loading
- 실제로 데이터가 필요할 때까지 연관된 참조 엔티티의 데이터를 로드하지 않고 해당 엔티티의 데이터만 읽어옵니다.

**장점**
- 필요한 시점에 데이터를 로드하기에 성능을 최적화하고 메모리 사용량을 줄일 수 있습니다.
- 불필요한 데이터 전송을 피하여 네트워크 부하를 줄일 수 있습니다.

**단점**
- 연관된 엔티티를 접근할 때마다 추가 쿼리가 발생하여 성능 저하가 발생할 수 있습니다.
- 연관된 엔티티가 여러 개인 경우 각 엔티티에 대해 개별 쿼리를 발생시키는 N+1문제가 발생할 수 있습니다.
- 트랜잭션 범위를 벗어난 연관 엔티티를 접근하는 경우 예외가 발생할 수 있습니다.
- LazyInitializationException이 발생할 수 있습니다.
  - FetchType.EAGER를 사용하여 해결할 수 있습니다.
  - DTO를 사용하여 필요한 데이터를 로드하고 전달하여 문제를 해결할 수 있습니다.
  - 트랜잭션 내에서 데이터를 접근하여 해결할 수 있습니다.

```Java
// Service method
public Parent getParent(Long id) {
    Parent parent = entityManager.find(Parent.class, id);
    parent.getChildren().size(); // children을 미리 로드
    return parent;
}
```

##### Eager Loading
- 연관된 모든 엔티티를 처음 로드할 때 함께 로드합니다.

**장점**
- 필요한 모든 데이터가 로드되어 있어 즉시 접근 가능하며, 일관적으로 트랜잭션을 처리할 수 있습니다.
- 모든 데이터가 로딩되어 있어 추가 쿼리가 필요 없으며 코드가 단순해집니다.

**단점**
- 초기 로딩시 성능저하가 발생할 수 있습니다.
- 필요하지 않은 데이터를 로드하여 메모리 사용량이 증가하고 네트워크 부하가 증가할 수 있습니다.

## JPA에서 N+1 문제를 해결하기 위한 방법을 설명해 주세요.

##### N+1문제
- 1:N, N:1 관계의 엔티티를 조회할 때 발생합니다.
- 하나의 엔티티를 조회할 때 그와 관련된 Child node를 조회하는 등 1번의 쿼리에 n개의 추가 쿼리가 발생하는 문제입니다.
- EAGER로 데이터를 조회하거나 LAZY로 데이터를 로딩 후 연관 하위 엔티티를 조회하는 경우에 발생할 수 있습니다.

##### 해결 1. Fetch join
- JPQL에서 성능 최적화를 위해 제공하는 기능으로 연관된 엔티티나 컬렉션을 한 번에 같이 조회할 수 있는 기능입니다.
  - 일반 조인은 2개 이상의 테이블을 조인하지만, 연관된 엔티티를 함께 조회하지 않습니다.
  - 단순히 두 테이블 간의 관계를 정의하고, 데이터베이스에서 필요한 데이터를 필터링하는 역할을 수행합니다.
  - 쿼리 결과에는 조인된 결과가 포함되지만, 연관된 엔티티는 메모리에 로드되어있지 않은 상태입니다.
- Fetch join을 사용하여 연관된 엔티티를 한 번의 쿼리로 로드합니다.
  - 연관된 테이블이 영속성 컨텍스트 1차 캐시에 저장되어 사용됩니다.
- 다른 테이블을 따로 조회하는 것이 아닌 JOIN 후 모든 데이터를 가져옵니다.
  - DISTINCT절을 이용하여 중복 데이터 조회를 회피합니다.
- 1:n 관계가 2개 이상인 경우 사용이 불가합니다.
  - 잘못된 결과를 반환할 수 있습니다.
- Paging API 사용이 불가능합니다.
  - Paging 적용시 모든 연관된 엔티티를 메모리에 로드하여 처리함으로 out of memery 문제가 발생할 수 있습니다.
  - 테이블의 데이터와 메모리에 영속화된 엔티티의 실제 관계가 일치하지 않을 수 있습니다.

##### 해결 2. Entity Graph
- entity graph는 지연로딩과 즉시로딩의 단점을 보완합니다.
- 특정 쿼리에서 필요한 연관 엔티티를 명시적으로 로드하여 n+1 문제를 해결합니다.
  - @EntityGraph(attributePaths = "books") 와 같이 연괸된 엔티티를 명시합니다.
  - 연괸된 엔티티들이 한 번의 쿼리로 함께 로드됩니다.
- 특정 상황에서 필요한 연관 엔티티를 로드하여 즉시 로딩의 불필요한 데이터 로딩 문제를 해결합니다.
  - 연관관계의 엔티티가 지연로딩으로 설정되어 있으면 종속된 엔티티는 select되지 않고 proxy obj를 만들어 적용됩니다.
  - 그 후 proxy obj를 호출할 때마다 select 쿼리가 실행됩니다.

## 통합 테스트와 단위 테스트의 차이점에 대해서 설명해주세요.

##### 단위테스트
- 함수, 메소드, 클래스와 같은 unit 단위로 테스트합니다.
- 특정 기능의 작은 부분을 격리된 환경에서 독립적으로 테스트합니다.
- 다른 부분에 영향을 주지않고 독립적으로 실행할 수 있어야하며 빠르게 실행 가능해야합니다.
- 한 가지 기능에 집중하여 테스트하며 mocking 객체를 이용하여 테스트를 진행할 수 있습니다.

##### 통합테스트
- 여러 개의 component가 모여 동작하는 전체 시스템의 통합을 검증하는 테스트입니다.
- 시스템 레벨의 더 큰 범위의 시스템을 대상으로 합니다.
- 여러 componenet 간의 상호작용과 연동을 테스트하며 외부 리소스나 데이터베이스 등의 의존성이 포함될 수 있습니다.

## 통합 테스트과 단위 테스트의 장/단점에 대해서 설명해주세요.

##### 단위 테스트 장점
- 개발 초기 빠르게 검증할 수 있어 빠르게 결함을 발견하고 수정할 수 있습니다.
- 코드의 예상 동작을 설명할 수 있는 문서 역할을 할 수 있으며, 문제 발생시 결함 부분을 빠르게 찾을 수 있습니다.
- 외부 리소스나 데이터베이스 접근 없이 테스트를 실행할 수 있기에 빠르게 테스트할 수 있습니다.
- 작성 과정에서 모듈의 인터페이스와 의존성을 명확히 이해하고, 코드의 결합도와 응집도를 개선할 수 있습니다.

##### 단위테스트 단점
- 모듈 간의 통합과 상호작용을 확인하는 것에 제한이 있을 수 있습니다.
- Mock 객체를 이용하기에 실제 환경과 차이가 있습니다.

##### 통합 테스트 장점
- 전체 시스템을 실제 동작처럼 검증할 수 있습니다.
- 다양한 component가 결합되었을 때 발견되는 문제를 발견할 수 있습니다.

##### 통합테스트 단점
- 실행 시간이 길어지고, 테스트 수행 시점이 늦어집니다.
- 오류 발생시 그 원인을 추적하기 어렵습니다.

## 레이어별로 나누어서 Slice Test를 하는 이유에 대해서 설명해주세요.
- 각 레이어를 통합하지 않고 레이어 기능을 테스트함으로써 테스트 환경을 더욱 통제하고, 테스트 실행의 예측 가능성을 높일 수 있습니다.
- 각 레이어에서 발생할 수 있는 오류를 더 빠르고 명확하게 식별할 수 있습니다.
- 각 레이어의 특정 기능이나 로직에 초점을 맞추어 테스트하기에 테스트케이스를 작성하고 관리하는 것에 효율적입니다.
- bean을 전부 로드하지 않고, 또한 데이터의 세팅 과정이 생략되어 테스트 속도가 빨라지고 코드 가독성이 높아집니다.

## 테스트 코드를 직접 짰을 때, 느낀 테스트 코드 작성의 필요성을 설명해주세요.
- 직접 작성하고 실행할 때는 오류가 나지 않은 입력을 알기에 예외처리에 미흡한 부분이 있었습니다.
- 테스트 코드를 구성하고 테스트 케이스를 작성하며 놓쳤던 예외 경우를 찾을 수 있었고, 일관되지 못한 응답 반환의 문제에 대해서도 알 수 있었습니다.

## JPA와 Hibernate의 차이점은 무엇인가요?
- JPA는 자바 ORM(자바 클래스와 DB테이블 매핑) 기술에 대한 API 표준 명세를 의미하며, ORM 기술의 인터페이스와 어노테이션의 표준집합입니다.
  - interface, enum, exception, Annotation 등을 통해 JPA를 정의합니다.
  - 다양한 ORM 프레임워크에서 구현할 수 있는 공통 API를 제공합니다.
- Hibernate는 JPA를 구현한 대표적은 ORM 프레임워크입니다.
  - JPA 표준을 이용하여 특정 구현 기술에 대한 의존도를 줄일 수 있습니다.

## QueryDSL을 사용하여 복잡한 동적 쿼리를 작성하는 방법을 설명해 주세요.

##### QueryDSL
- Entity의 매핑정보를 활용하여 쿼리에 적합하도록 쿼리 전용 클래스(Q클래스)로 재구성해주는 기술 입니다.
- QueryDSL은 도메인 모델을 사용하여 쿼리를 생성하기 때문에, 컴파일 시점에 쿼리의 정확성을 검증할 수 있습니다.
- 런타임 에러를 줄이고, 코드의 가독성과 유지보수성을 높일 수 있습니다.

##### Q타입 클래스

- 도메인 모델(엔터티 클래스)에서 자동으로 생성되는 쿼리 타입 클래스입니다.
- Q로 시작하는 이름을 가지며, 도메인 모델의 속성과 일치하는 필드를 포함합니다.
- 예를 들어, User 엔터티가 있다면 QUser 클래스가 생성됩니다.

##### JPAQueryFactory
- 재구성한 Q클래스를 통해 문자열이 아닌 객체 또는 함수로 쿼리를 작성하고 실행하게 해주는 기술 입니다.
- QueryDSL 쿼리를 작성하는 데 사용되는 클래스입니다.
- EntityManager를 사용하여 생성됩니다.
- 쿼리 실행 및 결과를 가져오는 기능을 제공합니다.

##### BooleanExpression

- 쿼리의 조건을 표현하는 데 사용됩니다.
- 메소드 체이닝을 통해 복잡한 조건을 쉽게 작성할 수 있습니다.

##### SQLQueryFactory

- SQL 쿼리를 작성하는 데 사용되는 클래스입니다.
- DataSource를 사용하여 생성됩니다.
- SQL 기반 데이터베이스와 상호작용할 수 있습니다.

##### 단계
- JPAQueryFactory 객체를 생성하고 이를 이용해 다양한 쿼리를 작성하고 실행합니다.
- BooleanBuilder를 사용하여 다양한 동적 조건을 생성합니다.

## 프로젝트에서 좋아요 기능을 구현할 때, 특정 사용자가 특정 게시글을 이미 좋아요 했는지 확인하는 방법을 설명해 주세요.
- 특정 게시글이 Likes 엔티티의 리스트를 가지고 있고, like 엔티티는 boolean인 liked를 false로 default값을 가지고 있습니다.
- Like 엔티티는 User 객체와 1:n관계를 가지고 있으며 특정 id의 like를 update할 때마다 좋아요 등록 혹은 취소가 동작합니다.
- 특정 게시글의 like 조회를 통해 좋아요 여부를 확인할 수 있습니다.

## Transaction
- 데이터베이스 응용에서 하나의 논리적 단위를 수행하는 데이터베이스 연산들의 모임
- 데이터 객체를 접근하고 갱신하는 프로그램 수행의 단위
- 데이터 베이스의 일관성 유지를 위해 사용되며, 동시성 제어와 회복 기능을 위해 사용됩니다.

> ## ACID
> ##### 원자성
> - 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음을 의미합니다.
> - 회복 모듈은 부분적으로 데이터베이스를 갱신한 Transaction의 영향을 취소함으로써 원자성을 보장합니다.
> - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장합니다.
> ##### 일관성
> - 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가져야합니다.
> ##### 고립성
> - 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션이 접근하지 못하도록 해야합니다.
> - 여러 트랜잭션이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션이 하나씩 차례대로 수행한 결과와 같아야합니다.
> ##### 지속성
> - 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않아야합니다.
> - 회복 모듈은 시스템 다운의 경우에도 트랜잭션의 지속성을 보장합니다.

##### 트랜잭션 처리방법
- 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터 베이스에 미치는 영향과 같도록 보장되어야합니다.

**직렬 스케줄**
- 여러 트랜잭션 집합을 한 번에 하나씩 차례대로 수행합니다.

**비직렬 스케줄**
- 여러 트랜잭션들을 동시에 수행합니다.

**직렬 가능**
- 비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행결과와 동등함을 의미합니다.
- 비직렬 스케줄을 동시성을 높이지만, 이를 위해 직렬가능성을 보장하여 데이터 일관성을 유지하여야합니다.

## 동시성 제어를 수행하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제

##### 갱신 손실(Lost Update)
- 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효가 됩니다.


```
예: 갱신 손실

- 하나의 SQL문은 DBMS 내에서 여러 개의 명령들로 나뉘어 수행된다. 다수 사용자 환경에서는 여러 사용자들이 동시에 요청한 트랜잭션의 명령들이 섞여서 수행될 수 있다. 
- 트랜잭션 T1은 X에서 Y로 100000을 이체하고, 트랜잭션 T2는 X의 값에 50000을 더하려고 한다. 
- 두 트랜잭션이 수행되기 전의 X와 Y의 초기값이 각각 300000과 600000이라고 가정하면 T1의 수행을 먼저 완료하고 T2의 수행을 완료하던지, 
- T2의 수행을 먼저 완료하고 T1의 수행을 완료하던지 관계 없이 X의 최종값은 250000, Y의 최종값은 700000이 되어야 한다.
```

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/a100c097-5eba-4260-9e32-e11c53416de8" height="50%" width = "50%"/></p>

##### 오손 데이터 읽기(dirty read)
- 완료되지 않은 트랜잭션이 갱신한 데이터를 읽습니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/b4ce8da3-7b2e-426b-990e-9fb9269a0951" height="50%" width = "50%"/></p>

```
예: 오손 데이터 읽기

- 위의 그림에서 트랜잭션 T1이 정미림의 잔액을 100000원 감소시킨 후에 트랜잭션 T2는 모든 계좌의 잔액의 평균값을 검색하였다.
- 그 이후에 T1이 어떤 이유로 철회되면 T1이 갱신한 정미림 계좌의 잔액은 원래 상태로 되돌아간다.
- 따라서 T2는 완료되지 않은 트랜잭션이 갱신한 데이터, 즉 틀린 데이터를 읽었다.
```

##### 반복할 수 없는 읽기(Unrepeatable read)
- 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽습니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/b4ce8da3-7b2e-426b-990e-9fb9269a0951" height="50%" width = "50%"/></p>

```
예: 반복할 수 없는 읽기

- 위의 그림에서 먼저 트랜잭션 T2는 모든 계좌의 잔액의 평균값을 검색하였다.
- 트랜잭션 T2가 완료되기 전에 트랜잭션 T1이 정미림의 잔액을 100000원 감소시키고 완료되었다. 
- 트랜잭션 T2가 다시 모든 계좌의 잔액의 평균값을 검색하면 첫 번째 평균값과 다른 값을 보게 된다. 
- 동일한 읽기 연산을 여러 번 수행할 때 매번 서로 다른 값을 보게 될 수 있다.
```

## Locking
- 데이터 항목을 로킹하는 개념은 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해 가장 널리 사용되는 기법입니다.
- lock는 데이터베이스 내의 각 데이터 항목과 연관된 하나의 변수이며, 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 로크에 대한 정보는 lock table에 저장됩니다.
- 트랜잭션에서 데이터 항목을 접근할 때 로크를 요청하고, 접근을 끝낸 후에는 로크를 해제합니다.

##### 갱신 목적 접근
- 독점 로크(X-lock, eXclusive lock)을 요청하여 데이터를 갱신합니다.

##### 판독 목적 접근
- 공유 로크(S-lock, Shared lock)을 요청하여 데이터를 열람합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/9bbb59fd-7002-49b9-bdf7-a7fe0211a696" height="70%" width = "70%"/></p>

## 2-phase locking protocol
- 로크를 요청하는 것과 로크를 해제하는 2단계로 이루어집니다.
- 로크 확장 단계를 수행한 후 로크 수축 단계를 수행합니다.
- 로크를 1개라도 해제한다면 로크 수축 단계를 수행합니다.

##### 로크 확장 단계
- 로크 확장 단계에서는 트랜잭션이 데이터 항목에 대하여 새로운 로크를 요청할 수 있지만, 보유하고 있던 로크를 해제할 수는 없습니다.

##### 로크 수축 단계
- 로크 수축 단계에서는 보유하고 있던 로크를 해제할 수 있지만 새로운 로크를 요청할 수 없습니다.
- 로크 수축 단계에서는 로크를 단계적으로 해제할 수도 있고, 트랜잭션의 완료 시점에 한 번에 모든 로크를 해제할 수 있습니다.
- 일반적으로 완료시점에서 한번에 해제하는 방식을 사용합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/481b3018-15c7-46f7-a7d6-a358f51bf476" height="70%" width = "70%"/></p>

- lock point는 한 트랜잭션에서 필요로 하는 모든 로크를 걸어놓은 시점을 의미합니다.

## Dead lock
- 2단계 로킹 프로토콜에서는 데드록이 발생할 수 있습니다.
- 2개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 로크를 요청하면서 기다리고 있는 상태를 지칭합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/6ed849a7-fd1e-4893-8b34-94c9f5cadfeb" height="50%" width = "50%"/></p>

## 다중 로크 단위
- 소수의 투플들을 접근하는 데이터베이스 응용에서는 투플 단위의 로크를 하여도 로크 테이블을 다루는 작업에 오랜 시간이 걸리지 않지만, 많은 투플을 접근하는 데이터베이스 응용에서는 투플 단위로만 로크를 진행한다면, 로크 테이블에서 로크 충돌을 검사하고 로크 정보를 기록하는 작업에서 많은 지연이 발생합니다.
- 따라서 트랜잭션이 접근하는 투플 수에 따라 로크를 수행하는 데이터 항목의 단위를 구분하는 것이 필요하며, 한 트랜잭션에서 로클할 수 있는 데이터 항목이 2가지 이상 있다면 다중 로크 단위라고 지칭합니다.
- 로크 가능 단위 : 데이터베이스 / 릴레이션 / 디스크 블록 / 투플 등
- 로크 단위가 작아질수록 오버헤드가 증가하고 동시성의 정도도 증가합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/dc55eb76-3653-4000-8011-ca9634230f37" height="70%" width = "70%"/></p>

## 팬텀 문제
- 두 번의 SELECT문을 수행할 때, SELECT문 사이에 INSERT문이 수행된다면 첫번째 데이터 조회시 조회할 수 없었던 데이터가 2번째 데이터 조회시에 등장할 수 있습니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/cf999eae-7e39-47d1-8c3e-a49efa20226f" height="70%" width = "70%"/></p>