---
layout: single
title:  "[JavaSpring] 모의 면접 2차"
date:   2024-06-27 09:00:00 +0900
categories: JavaSpring
author_profile: true
sidebar:
  nav: "main"
tags : 
    - JavaSpring
---

## JPA에서 Lazy Loading과 Eager Loading의 차이점은 무엇인가요? 각각의 장단점에 대해 설명해 주세요.

##### Lazy loading
- 실제로 데이터가 필요할 때까지 연관된 참조 엔티티의 데이터를 로드하지 않고 해당 엔티티의 데이터만 읽어옵니다.

**장점**
- 필요한 시점에 데이터를 로딩하기에 메모리 사용량을 줄일 수 있습니다.
- 불필요한 데이터 전송을 피하여 네트워크 부하를 줄일 수 있습니다.

**단점**
- 연관된 데이터가 여러 번 로드될 경우 추가 쿼리가 발생하여 성능 저하가 있을 수 있습니다.
- 트랜잭션 범위를 벗어난 연관 엔티티를 접근하는 경우 예외가 발생할 수 있습니다.

##### Eager Loading
- 연관된 모든 엔티티를 처음 로드할 때 함께 로드합니다.

**장점**
- 필요한 모든 데이터가 로드되어 있어 즉시 접근 가능하며, 일관적으로 트랜잭션을 처리할 수 있습니다.
- 모든 데이터가 로딩되어 있어 추가 쿼리가 필요없습니다.

**단점**
- 초기 로딩시 성능저하가 발생할 수 있습니다.
- 필요하지 않은 데이터를 로드하여 메모리 사용량이 증가하고 네트워크 부하가 증가할 수 있습니다.

## JPA에서 N+1 문제를 해결하기 위한 방법을 설명해 주세요.

##### N+1문제
- 1:N, N:1 관계의 엔티티를 조회할 때 발생합니다.
- 하나의 엔티티를 조회할 때 그와 관련된 Child node를 조회하는 등 1번의 쿼리에 n개의 추가 쿼리가 발생하는 문제입니다.
- EAGER로 데이터를 조회하거나 LAZY로 데이터를 로딩 후 연관 하위 엔티티를 조회하는 경우에 발생할 수 있습니다.

##### 해결 1. Fetch join
- Fetch join을 사용하여 연관된 엔티티를 한 번의 쿼리로 로드합니다.
- 다른 테이블을 따로 조회하는 것이 아닌 JOIN 후 모든 데이터를 가져옵니다.
  - DISTINCT절을 이용하여 중복 데이터 조회를 회피합니다.
- 1:n 관계가 2개 이상인 경우 사용이 불가하고 Paging API 사용이 불가능합니다.

##### 해결 2. Entity Graph
- entity graph는 지연로딩과 즉시로딩의 단점을 보완합니다.
- 특정 쿼리에서 필요한 연관 엔티티를 명시적으로 로드하여 n+1 문제를 해결합니다.
- 특정 상황에서 필요한 연관 엔티티를 로드하여 즉시 로딩의 불필요한 데이터 로딩 문제를 해결합니다.

## 통합 테스트와 단위 테스트의 차이점에 대해서 설명해주세요.

##### 단위테스트
- 함수, 메소드, 클래스와 같은 unit 단위로 테스트합니다.
- 특정 기능의 작은 부분을 격리된 환경에서 독립적으로 테스트합니다.
- 다른 부분에 영향을 주지않고 독립적으로 실행할 수 있어야하며 빠르게 실행 가능해야합니다.
- 한 가지 기능에 집중하여 테스트하며 mocking 객체를 이용하여 테스트를 진행할 수 있습니다.

##### 통합테스트
- 여러 개의 component가 모여 동작하는 전체 시스템의 통합을 검증하는 테스트입니다.
- 시스템 레벨의 더 큰 범위의 시스템을 대상으로 합니다.
- 여러 componenet 간의 상호작용과 연동을 테스트하며 외부 리소스나 데이터베이스 등의 의존성이 포함될 수 있습니다.

## 통합 테스트과 단위 테스트의 장/단점에 대해서 설명해주세요.

##### 단위 테스트 장점
- 개발 초기 빠르게 검증할 수 있어 빠르게 결함을 발견하고 수정할 수 있습니다.
- 코드의 예상 동작을 설명할 수 있는 문서 역할을 할 수 있으며, 문제 발생시 결함 부분을 빠르게 찾을 수 있습니다.
- 외부 리소스나 데이터베이스 접근 없이 테스트를 실행할 수 있기에 빠르게 테스트할 수 있습니다.

##### 통합 테스트 장점
- 전체 시스템을 실제 동작처럼 검증할 수 있습니다.
- 다양한 component가 결합되었을 때 발견되는 문제를 발견할 수 있습니다.

## 레이어별로 나누어서 Slice Test 를 하는 이유에 대해서 설명해주세요.
- 각 레이어의 의존성을 최소화하여 테스트의 신속성과 독립성을 유지합니다.
- 각 레이어에서 발생할 수 있는 오류를 더 빠르고 명확하게 식별할 수 있습니다.
- 협업 시 담당하는 레이어를 집중적으로 테스트함으로써 코드 변경이나 기능 개선이 다른 부분에 어떤 영향을 미칠지 명확하게 파악할 수 있습니다.

## 테스트 코드를 직접 짰을 때, 느낀 테스트 코드 작성의 필요성을 설명해주세요.
- 직접 작성하고 실행할 때는 오류가 나지 않은 입력을 알기에 예외처리에 미흡한 부분이 있었습니다.
- 테스트 코드를 구성하고 테스트 케이스를 작성하며 놓쳤던 예외 경우를 찾을 수 있었고, 일관되지 못한 응답 반환의 문제에 대해서도 알 수 있었습니다.

## JPA와 Hibernate의 차이점은 무엇인가요?
- JPA(자바 클래스와 DB테이블 매핑)는 자바 ORM 기술에 대한 API 표준 명세를 의미하며, ORM 기술의 인터페이스와 어노테이션의 표준집합입니다.
  - interface, enum, exception, Annotation 등을 통해 JPA를 정의합니다.
  - 다양한 ORM 프레임워크에서 구현할 수 있는 공통 API를 제공합니다.
- Hibernate는 JPA를 구현한 대표적은 ORM 프레임워크입니다.
  - JPA 표준을 이용하여 특정 구현 기술에 대한 의존도를 줄일 수 있습니다.
## QueryDSL을 사용하여 복잡한 동적 쿼리를 작성하는 방법을 설명해 주세요.

## 프로젝트에서 좋아요 기능을 구현할 때, 특정 사용자가 특정 게시글을 이미 좋아요 했는지 확인하는 방법을 설명해 주세요.
- 특정 게시글이 Likes 엔티티의 리스트를 가지고 있습니다.
- Like 엔티티는 User 객체와 boolean타입의 liked를 가지고 있으며 좋아요 여부를 확인합니다.

## Transaction
- 데이터베이스 응용에서 하나의 논리적 단위를 수행하는 데이터베이스 연산들의 모임
- 데이터 객체를 접근하고 갱신하는 프로그램 수행의 단위

- 계좌 이체의 예처럼 하나의 Transaction이 수행중 시스템이 다운되는 경우 일관성을 보장하기 위해 사용됩니다.

## ACID

##### 원자성
- 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음을 의미합니다.
- 회복 모듈은 부분적으로 데이터베이스를 갱신한 Transaction의 영향을 취소함으로써 원자성을 보장합니다.
- 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장합니다.

##### 일관성
- 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가져야합니다.

##### 고립성
- 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션이 접근하지 못하도록 해야합니다.
- 여러 트랜잭션이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션이 하나씩 차례대로 수행한 결과와 같아야합니다.

##### 지속성
- 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않아야합니다.
- 회복 모듈은 시스템 다운의 경우에도 트랜잭션의 지속성을 보장합니다.