---
layout: single
title:  "[Database] Transaction"
date:   2024-06-28 09:15:00 +0900
categories: Database
author_profile: true
sidebar:
  nav: "main"
tags : 
    - Database
---

## 동시성 제어와 회복
- 항공기 예약, 은행 등 대규모 데이터베이스를 수천명 이상의 사용자들이 동시에 접근하며, 동시에 서로 다른 또는 동일한 부분을 접근하면서 데이터베이스를 사용합니다.

##### Concurrency Control
- 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스 미치는 영향과 같도록 보장하여야합니다.
- 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서도 데이터 베이스 일관성을 유지할 수 있어야합니다.

##### Recovery
- 데이터베이스를 갱신하는 도중에 시스템이 고장나도 데이터베이스의 일관성을 유지해야합니다.

## Transaction
- 데이터베이스 응용에서 하나의 논리적인 단위를 수행하는 데이터베이스 연산들의 모임입니다.
- 데이터 객체를 접근하고 갱신하는 프로그램 수행의 단위입니다.
- 여러 SQL문이 데이터베이스를 수정할 때 이 SQL문들을 DBMS가 하나의 트랜잭션으로 처리하여 완전히 수행되거나 하나도 수행하여 일관성을 유지할 수 있도록 관리합니다.

## 트랜잭션의 특성

##### Atomicity
- 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않습니다.
- DBMS 회복 모듈은 시스템이 다운되는 경우, 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장합니다.
- 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장합니다.

##### Consistency
- 어떤 트랜잭션이 수행되기 전 데이터 베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에도 데이터 베이스는 또다른 일관된 상태를 가져야합니다.

##### Isolation
- 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 합니다.
- 다수의 트랜잭션이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야합니다.
- DBMS의 동시서 제어 모듈이 트랜잭션의 고립성을 보장하며, 요구사항에 따라 다양한 고립수준이 제공됩니다.

##### Durability
- 트랜잭션이 완료된 후 갱신된 내용은 이후 시스템의 고장이 발생하더라도 손실되지 않습니다.
- DBMS의 회복모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/b9869b69-04ec-4694-bc44-fd1cc4cafcf7" height="70%" width = "70%"/></p>

## 트랜잭션의 완료
- 트랜잭션에 변경하려는 내용이 데이터베이스에 완전하게 반영됩니다.
- SQL 구문상으로 COMMIT WORK입니다.

## 트랜잭션의 철회
- 트랜잭션이 변경하려는 내용이 일부만 반영된 경우 원자성을 보장하기 위해 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌립니다.
- SQL 구문상으로 ROLLBACK WORK입니다.

## 동시성 제어
- 대부분의 DBMS는 다수 사용자용이며 성능을 높이기 위해 여러 사용자의 질의나 프로그램을 동시에 수행합니다.
- 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션을 동시에 수행하는 환경에서 트랜잭션 간의 간섭이 생기지 않도록 관리합니다.

##### serial schedule
- 여러 트랜잭션들의 집합을 한 번에 한 트랜잭션씩 차례대로 수행합니다.

##### non-serial schedule
- 여러 트랜잭션들을 동시에 수행합니다.

##### serializable
- 비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행 결과와 동등합니다.

## 데이터베이스의 연산
- Input(X) 연산은 데이터베이스 항목 X를 포함하고 있는 블록을 주기억 장치의 버퍼로 읽어들입니다.
- Output(X) 연산은 데이터베이스 항목 X를 포함하고 있는 블록을 디스크에 기록합니다.
- read_item(X) 연산은 주기억 장치 버퍼에서 데이터베이스 항목 X의 값을 프로그램 변수 X로 복사합니다.
- write_item(X) 연산은 프로그램 변수 X의 값을 주기억 장치 내의 데이터베이스 항목 X에 기록합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/a8715315-e04e-44de-a0bf-5e5f04830198" height="50%" width = "50%"/></p>

## 동시성 제어를 수행하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제

##### 갱신 손실(Lost Update)
- 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효가 됩니다.


```
예: 갱신 손실

- 하나의 SQL문은 DBMS 내에서 여러 개의 명령들로 나뉘어 수행된다. 다수 사용자 환경에서는 여러 사용자들이 동시에 요청한 트랜잭션의 명령들이 섞여서 수행될 수 있다. 
- 트랜잭션 T1은 X에서 Y로 100000을 이체하고, 트랜잭션 T2는 X의 값에 50000을 더하려고 한다. 
- 두 트랜잭션이 수행되기 전의 X와 Y의 초기값이 각각 300000과 600000이라고 가정하면 T1의 수행을 먼저 완료하고 T2의 수행을 완료하던지, 
- T2의 수행을 먼저 완료하고 T1의 수행을 완료하던지 관계 없이 X의 최종값은 250000, Y의 최종값은 700000이 되어야 한다.
```

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/a100c097-5eba-4260-9e32-e11c53416de8" height="50%" width = "50%"/></p>

##### 오손 데이터 읽기(dirty read)
- 완료되지 않은 트랜잭션이 갱신한 데이터를 읽습니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/b4ce8da3-7b2e-426b-990e-9fb9269a0951" height="50%" width = "50%"/></p>

```
예: 오손 데이터 읽기

- 위의 그림에서 트랜잭션 T1이 정미림의 잔액을 100000원 감소시킨 후에 트랜잭션 T2는 모든 계좌의 잔액의 평균값을 검색하였다.
- 그 이후에 T1이 어떤 이유로 철회되면 T1이 갱신한 정미림 계좌의 잔액은 원래 상태로 되돌아간다.
- 따라서 T2는 완료되지 않은 트랜잭션이 갱신한 데이터, 즉 틀린 데이터를 읽었다.
```

##### 반복할 수 없는 읽기(Unrepeatable read)
- 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽습니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/b4ce8da3-7b2e-426b-990e-9fb9269a0951" height="50%" width = "50%"/></p>

```
예: 반복할 수 없는 읽기

- 위의 그림에서 먼저 트랜잭션 T2는 모든 계좌의 잔액의 평균값을 검색하였다.
- 트랜잭션 T2가 완료되기 전에 트랜잭션 T1이 정미림의 잔액을 100000원 감소시키고 완료되었다. 
- 트랜잭션 T2가 다시 모든 계좌의 잔액의 평균값을 검색하면 첫 번째 평균값과 다른 값을 보게 된다. 
- 동일한 읽기 연산을 여러 번 수행할 때 매번 서로 다른 값을 보게 될 수 있다.
```

## Locking
- 데이터 항목을 로킹하는 개념은 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해 가장 널리 사용되는 기법입니다.
- lock는 데이터베이스 내의 각 데이터 항목과 연관된 하나의 변수이며, 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 로크에 대한 정보는 lock table에 저장됩니다.
- 트랜잭션에서 데이터 항목을 접근할 때 로크를 요청하고, 접근을 끝낸 후에는 로크를 해제합니다.

##### 갱신 목적 접근
- 독점 로크(X-lock, eXclusive lock)을 요청하여 데이터를 갱신합니다.

##### 판독 목적 접근
- 공유 로크(S-lock, Shared lock)을 요청하여 데이터를 열람합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/9bbb59fd-7002-49b9-bdf7-a7fe0211a696" height="70%" width = "70%"/></p>

## 2-phase locking protocol
- 로크를 요청하는 것과 로크를 해제하는 2단계로 이루어집니다.
- 로크 확장 단계를 수행한 후 로크 수축 단계를 수행합니다.
- 로크를 1개라도 해제한다면 로크 수축 단계를 수행합니다.

##### 로크 확장 단계
- 로크 확장 단계에서는 트랜잭션이 데이터 항목에 대하여 새로운 로크를 요청할 수 있지만, 보유하고 있던 로크를 해제할 수는 없습니다.

##### 로크 수축 단계
- 로크 수축 단계에서는 보유하고 있던 로크를 해제할 수 있지만 새로운 로크를 요청할 수 없습니다.
- 로크 수축 단계에서는 로크를 단계적으로 해제할 수도 있고, 트랜잭션의 완료 시점에 한 번에 모든 로크를 해제할 수 있습니다.
- 일반적으로 완료시점에서 한번에 해제하는 방식을 사용합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/481b3018-15c7-46f7-a7d6-a358f51bf476" height="70%" width = "70%"/></p>

- lock point는 한 트랜잭션에서 필요로 하는 모든 로크를 걸어놓은 시점을 의미합니다.

## Dead lock
- 2단계 로킹 프로토콜에서는 데드록이 발생할 수 있습니다.
- 2개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 로크를 요청하면서 기다리고 있는 상태를 지칭합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/6ed849a7-fd1e-4893-8b34-94c9f5cadfeb" height="50%" width = "50%"/></p>

## 다중 로크 단위
- 소수의 투플들을 접근하는 데이터베이스 응용에서는 투플 단위의 로크를 하여도 로크 테이블을 다루는 작업에 오랜 시간이 걸리지 않지만, 많은 투플을 접근하는 데이터베이스 응용에서는 투플 단위로만 로크를 진행한다면, 로크 테이블에서 로크 충돌을 검사하고 로크 정보를 기록하는 작업에서 많은 지연이 발생합니다.
- 따라서 트랜잭션이 접근하는 투플 수에 따라 로크를 수행하는 데이터 항목의 단위를 구분하는 것이 필요하며, 한 트랜잭션에서 로클할 수 있는 데이터 항목이 2가지 이상 있다면 다중 로크 단위라고 지칭합니다.
- 로크 가능 단위 : 데이터베이스 / 릴레이션 / 디스크 블록 / 투플 등
- 로크 단위가 작아질수록 오버헤드가 증가하고 동시성의 정도도 증가합니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/dc55eb76-3653-4000-8011-ca9634230f37" height="70%" width = "70%"/></p>

## 팬텀 문제
- 두 번의 SELECT문을 수행할 때, SELECT문 사이에 INSERT문이 수행된다면 첫번째 데이터 조회시 조회할 수 없었던 데이터가 2번째 데이터 조회시에 등장할 수 있습니다.

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/cf999eae-7e39-47d1-8c3e-a49efa20226f" height="70%" width = "70%"/></p>