---
layout: single
title:  "Algorithm - Sorting : Heap Sort"
date:   2024-05-02 10:08:52 +0900
categories: Algorithm Sorting
author_profile: true
sidebar:
  nav: "main"
tags : 
    - Algorithm
    - Sorting
---
## Binary tree
- 완전이진트리 - Complete Binary Tree
    - 트리 내부의 모든 마디에 2개의 자식마디가 있는 이진트리
    - 모든 leaf node의 깊이는 동일하다.
<p align='center'><img src = "https://github.com/Bomin-Seo/Java_Spring/assets/94039896/9a1ca64f-0be0-483d-bec9-33015c3e10c4" height="20%" width = "20%"/></p>

- 실질적 완전이진트리 - Essentially Complete Binary Tree
    - 깊이 d-1까지 완전이진트리이며, 깊이 d의 마디는 왼쪽 끝에서부터 채워진 이진트리
<p align='center'><img src = "https://github.com/Bomin-Seo/Java_Spring/assets/94039896/7592ef77-23d0-40b3-9b75-59254b2a5e2b" height="20%" width = "20%"/></p>

- Full Binary Tree
    - 모든 노드가 0 또는 2개의 자식노드를 갖는 이진트리
<p align='center'><img src = "https://github.com/Bomin-Seo/Java_Spring/assets/94039896/59fbb53d-5fe0-4ca1-98b0-505890fef948" height="20%" width = "20%"/></p>

## Heap
-  heap의 성질 : max heap의 경우 어떤 마디의 저장된 값은 그 마디의 자식마디에 저장된 값보다 크거나 같고, \
min heap의 경우 어떤 마디의 저장된 값은 그 마디의 자식마디에 저장된 값보다 작거나 같다.
- heap : 힙의 성질을 만족하는 실질적인 완전이진트리

<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/7b69b0ea-f29d-4999-9ea9-2a96581254c4" height="30%" width = "30%"/></p>

##### Heap(Max heap)의 특성
- 우선 순위에 따라 큰 key에 자주 접근하거나 key를 중심으로 정렬된 sequence를 활용하는 경우 유용하게 사용되는 자료구조
- 최대값의 확인 : $$O(1)$$
- 최대값 제거 및 heap 재구성 : $$O(\log(n))$$
- 데이터 추가, 삭제, 변경 : $$O(\log(n))$$

##### Heap 구조의 해석 : index가 1부터 시작하는 경우
- index i 노드의
    - left child index : 2 * i
    - right child index : 2 * i + 1
    - parent node index : $$\lfloor i/2 \rfloor$$

## Heap Sort
- 입력되는 데이터를 heap으로 구성(heapify) 후 root data를 사용하여 정렬합니다.
- heap을 구성하는 방법으로는 데이터가 입력되는 순서대로 heap을 매번 구성하는 방법과 모든 데이터를 입력한 후 heap을 구성하는 방법이 있습니다.

##### Shift-Down
- heap 성질을 만족할 수 있도록 트리를 재구성하는 방법
    - root에 있는 key가 heap성질을 만족하지 않을 때
<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/c80d4752-9a69-45c6-9197-ae5d2c93935f" height="70%" width = "70%"/></p>

- root node와 교체될 child node를 결정하기 위해 한 번의 shift-down연산에서 2번의 비교 연산이 수행됩니다.

##### Shift-up
- heap 성질을 만족할 수 있도록 트리를 재구성하는 방법
    - 새로 추가된 데이터가 heap의 성질을 만족하지 않을 때 부모 노드와의 값을 비교하여 자리를 교환합니다.
- 한 번의 shift-up연산에서 1번의 비교 연산이 수행됩니다.

##### 방법 1
- 데이터가 입력되는 순서대로 heap을 구성하기 위해 shift-up 수행
<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/92be4e76-d87b-497d-b251-2690daefe293" height="70%" width = "70%"/></p>

##### Worst case 시간 복잡도 분석 : 단위연산 - Shift-up에서의 비교연산 횟수
- 데이터의 개수가 n(= $$2^k$$라 가정)인 경우 트리의 깊이 d는 $$d=\log(n)$$이며 d의 깊이를 가지는 마디는 정확히 하나 존재하며, d개의 조상을 가집니다.
- 마지막 원소를 제외하고 생각한다면 n-1개의 데이터는 깊이가 d-1인 완전이진트리를 형성합니다.
<p align='center'><img src = "https://github.com/Bomin-Seo/project1/assets/94039896/912d23a6-5df9-4e97-8134-c37d51c17c66" height="30%" width = "30%"/></p>

- 이 완전이진트리를 구성하는 동안 shift-up의 최대값은 다음을 만족합니다.

|depth|node 수|key가 shift-up되는 최대횟수|
|:---:|:---:|:---:|
|0|$$2^0$$|0|
|1|$$2^1$$|1|
|...|...|...|
|j|$$2^j$$|j|
|...|...|...|
|d-1|$$2^{d-1}$$|d-1|

- 따라서 총 shift-up의 횟수는 $$S = \sum^{d-1}_{j=0} j2^j$$이며 \
$$S = 1*2^1 + 2*2^2 + ... + (d-2)*2^{d-2} + (d-1)*2^{d-1} \dots (1)$$ \
$$2S = 1*2^2 + 2*2^3 + ... + (d-2)*2^{d-1} + (d-1)*2^{d} \dots (2)$$
- $$(2) - (1) = S = (d-1)*2^d - (2^1+2^2+...+2^{d-1}) = (\log(n)-1)*n - \frac{2(2^{d-1} - 1)}{2-1} = n\log(n)-2n + 2$$ 로 계산됩니다.
- 제외했던 깊이가 d인 n번째 node를 고려한다면 추가적으로 $$d=\log(n)$$의 shift-up이 필요하므로 총 연산횟수는 $$(n+1)\log(n) - 2n + 2$$이 되며 \
즉 $$O(n\log(n))$$의 시간이 필요하게 됩니다. (n이 충분히 큰 경우 $$(n+1)\log(n) > 2n$$)

##### 방법 2
- 모든 데이터를 트리에 넣은 상태에서 heap 구성

##### Worst case 시간 복잡도 분석 : 단위연산 - Shift-Down에서의 비교연산 횟수
- 방법 1과 같은 상황을 가정한 경우 n-1개의 데이터로 깊이가 d-1인 트리가 먼저 구성됩니다.
- depth 0에 위치한 데이터가 shift-down을 수행할 횟수는 최대 d-1번이며 depth과 1인 경우는 d-2, ... , depth가 d-1인 경우는 0번입니다.

|depth|node 수|key가 shift-down되는 최대횟수|
|:---:|:---:|:---:|
|0|$$2^0$$|d-1|
|1|$$2^1$$|d-2|
|...|...|...|
|j|$$2^j$$|d-j-1|
|...|...|...|
|d-1|$$2^{d-1}$$|0|

- 따라서 총 shift-down의 횟수는$$S = \sum^{d-1}_{j=0} (d- j - 1)2^j$$이며 $$n - \log(n) - 1$$로 표현됩니다.
- 제외했던 깊이가 d인 n번째 node가 추가되었을 때 추가되는 shift-down의 비교 연산이 최대로 수행되는 경우는 새로 추가된 데이터로 인해 d개의 조상이 shift-down되는 경우입니다.
- 이 경우 한 번의 shift-down에서 2번의 비교 연산이 수행되므로 추가적으로 2(d-1)번의 추가 연산이 필요합니다.
- 따라서 총 비교연산의 횟수는 $$3n -\log(n) - 3$$이며 $$O(n)$$의 시간이 필요하게 됩니다.

### python code 1
```
def split(values, first, last):
    splitval = values[first]
    savefirst = first
    first += 1
    while True:
        onCollectSide = True
        while onCollectSide:
            if values[first] > splitval:
                onCollectSide = False
            else:
                first += 1
                onCollectSide = (first <= last)
        onCollectSide = (first <= last)
        while onCollectSide:
            if values[last] <= splitval:
                onCollectSide = False
            else:
                last -= 1
                onCollectSide = (first <= last)
        if first < last:
            temp = values[first]
            values[first] = values[last]
            values[last] = temp
            first += 1
            last -= 1
        if first <= last:
            continue
        break
    splitPoint = last
    temp1 = values[savefirst]
    values[savefirst] = values[splitPoint]
    values[splitPoint] = temp1
    return splitPoint


def quick_sort(values, first, last):
    if first < last:
        splitPoint = split(values, first, last)
        quick_sort(values, first, splitPoint - 1)
        quick_sort(values, splitPoint + 1, last)
    return values
```
### python code 2
```
def partition(data, low, high, pivotpoint):
    global compare_count  # 재귀로 호출될 때 값을 새로 할당하지 않기 위해 전역 변수로 선언
    pivotitem = data[low]  # pivotitem으로 첫번째 항목을 고릅니다
    j = low  # low값을 유지하기 위해 새로운 변수 j에 low값을 할당합니다.
    for i in range(low + 1, high):
        if data[i] < pivotitem:
            j += 1
            # data[i]가 pivotitem보다 작을때만 j를 증가시킴으로써,
            # j는 pivotitem보다 작은 그룹의 제일 오른쪽 요소의 index를 나타냅니다
            data[i], data[j] = data[j], data[i]
            compare_count += 1
    pivotpoint[0] = j
    # pivotpoint를 pivotitem보다 작은 그룹의 가장 오른쪽 index로 지정합니다.
    data[low], data[pivotpoint[0]] = data[pivotpoint[0]], data[low]
    # data의 첫번째 요소와 pivotitem보다 작은 값을 서로 바꿈으로써
    # pivotitem 왼쪽에는 작은 값이, 오른쪽에는 같거나 큰 값이 분류됩니다.


def quicksort(data, low, high):
    pivotpoint = [0]
    if high > low:  # 적어도 데이터의 개수가 2개 이상일 경우, quick sort 수행
        partition(data, low, high, pivotpoint)
        # Pivot item을 기준으로 작은 값을 왼쪽으로, 같거나 큰 값을 오른쪽으로 분류합니다
        quicksort(data, low, pivotpoint[0] - 1)
        # pivotitem보다 작은 값을 가지는 데이터를 다시 quicksort를 수행합니다.
        quicksort(data, pivotpoint[0] + 1, high)
        # pivotitem보다 큰 값을 가지는 데이터를 다시 quicksort를 수행합니다.
```

### python code 3
```
def partition(array, low, high):

    # Choose the rightmost element as pivot
    pivot = array[high]

    # Pointer for greater element
    i = low - 1

    # Traverse through all elements
    # compare each element with pivot
    for j in range(low, high):
        if array[j] <= pivot:

            # If element smaller than pivot is found
            # swap it with the greater element pointed by i
            i = i + 1

            # Swapping element at i with element at j
            (array[i], array[j]) = (array[j], array[i])

    # Swap the pivot element with
    # the greater element specified by i
    (array[i + 1], array[high]) = (array[high], array[i + 1])

    # Return the position from where partition is done
    return i + 1


# Function to perform quicksort
def quicksort(array, low, high):
    if low < high:

        # Find pivot element such that
        # element smaller than pivot are on the left
        # element greater than pivot are on the right
        pi = partition(array, low, high)

        # Recursive call on the left of pivot
        quicksort(array, low, pi - 1)

        # Recursive call on the right of pivot
        quicksort(array, pi + 1, high)
```

### java code
```
import java.io.*;

class GFG {

    // A utility function to swap two elements
    static void swap(int[] arr, int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // This function takes last element as pivot,
    // places the pivot element at its correct position
    // in sorted array, and places all smaller to left
    // of pivot and all greater elements to right of pivot
    static int partition(int[] arr, int low, int high)
    {
        // Choosing the pivot
        int pivot = arr[high];

        // Index of smaller element and indicates
        // the right position of pivot found so far
        int i = (low - 1);

        for (int j = low; j <= high - 1; j++) {

            // If current element is smaller than the pivot
            if (arr[j] < pivot) {

                // Increment index of smaller element
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }

    // The main function that implements QuickSort
    // arr[] --> Array to be sorted,
    // low --> Starting index,
    // high --> Ending index
    static void quickSort(int[] arr, int low, int high)
    {
        if (low < high) {

            // pi is partitioning index, arr[p]
            // is now at right place
            int pi = partition(arr, low, high);

            // Separately sort elements before
            // partition and after partition
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    // To print sorted array
    public static void printArr(int[] arr)
    {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    // Driver Code
    public static void main(String[] args)
    {
        int[] arr = { 10, 7, 8, 9, 1, 5 };
        int N = arr.length;

        // Function call
        quickSort(arr, 0, N - 1);
        System.out.println("Sorted array:");
        printArr(arr);
    }
}
```